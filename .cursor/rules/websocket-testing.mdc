# WebSocket Testing Best Practices

This rule documents best practices for testing WebSocket applications, particularly in the context of the Agentic Service Bot.

<rule>
name: websocket_testing
description: Best practices for testing WebSocket applications
filters:
  - type: file_extension
    pattern: "\\.py$"
  - type: content
    pattern: "(?:websocket|WebSocket|ws\\.)"

actions:
  - type: suggest
    conditions:
      # If using sleep for waiting
      - pattern: "time\\.sleep\\(\\d+\\)"
        message: "Consider using event-based waiting instead of fixed sleep times"
      # If not using threading.Event for signaling
      - pattern: "(?:websocket|WebSocket).*(?!threading\\.Event)"
        message: "Use threading.Event for signaling in WebSocket communication"
      # If not handling both acknowledgment and actual responses
      - pattern: "on_message.*\\{.*\\}"
        message: "Ensure WebSocket message handler distinguishes between acknowledgment and actual responses"
    message: |
      ## WebSocket Testing Best Practices

      Follow these guidelines for testing WebSocket applications:

      1. **Use Event-Based Waiting**
         - Use `threading.Event` objects instead of fixed `time.sleep()` calls
         - Set events in message handlers when specific messages are received
         - Wait on events with reasonable timeouts instead of sleeping

      2. **Handle Different Message Types**
         - Distinguish between acknowledgment messages and actual responses
         - Store all raw messages for debugging purposes
         - Parse and validate message formats consistently

      3. **Optimize Wait Times**
         - Use shorter timeouts with retry mechanisms instead of long waits
         - Implement progressive backoff for retries
         - Log detailed information about wait states and timeouts

      4. **Manage WebSocket Connections Efficiently**
         - Reuse connections when possible
         - Properly close connections after tests
         - Handle connection errors gracefully

      5. **Implement Robust Message Tracking**
         - Track all received messages for debugging
         - Log parsed message content and structure
         - Maintain separate lists for different message types

      6. **Use Parallel Processing for Database Verification**
         - Implement polling with timeouts for database checks
         - Use functions that retry database operations with backoff
         - Avoid fixed wait times before database verification

      ### Example:
      ```python
      # Connection with event-based waiting
      def connect_websocket(self, customer_id=None):
          # Create events for signaling
          self.connection_established_event = threading.Event()
          self.message_received_event = threading.Event()
          
          # Define callbacks
          def on_open(ws):
              self.connection_established_event.set()
          
          def on_message(ws, message):
              # Store and parse message
              parsed_message = json.loads(message)
              self.all_received_messages.append(parsed_message)
              
              # Signal message received
              self.message_received_event.set()
          
          # Create and start WebSocket
          self.ws = websocket.WebSocketApp(url, on_open=on_open, on_message=on_message)
          wst = threading.Thread(target=self.ws.run_forever)
          wst.daemon = True
          wst.start()
          
          # Wait for connection with timeout
          if not self.connection_established_event.wait(timeout=5):
              raise ConnectionError("WebSocket connection timed out")
      
      # Message sending with event-based response waiting
      def send_message(self, message):
          # Clear previous state
          self.message_received_event.clear()
          self.all_received_messages = []
          
          # Send message
          self.ws.send(json.dumps(message))
          
          # Wait for initial response
          if not self.message_received_event.wait(timeout=5):
              logger.warning("No initial response received")
          
          # Wait for actual response (not just acknowledgment)
          start_time = time.time()
          max_wait_time = 20
          
          while time.time() - start_time < max_wait_time:
              # Check for actual response vs. acknowledgment
              for msg in self.all_received_messages:
                  if is_actual_response(msg):
                      return msg
              
              # Wait for more messages with short timeout
              self.message_received_event.wait(timeout=0.5)
              self.message_received_event.clear()
          
          return None
      ```

examples:
  - input: |
      # Bad: Using fixed sleep times
      def test_websocket():
          ws = connect_to_websocket()
          ws.send(json.dumps({"action": "test"}))
          time.sleep(10)  # Wait for response
          assert len(received_messages) > 0
    output: |
      # Good: Using event-based waiting
      def test_websocket():
          ws = connect_to_websocket()
          message_received = threading.Event()
          
          def on_message(ws, message):
              received_messages.append(json.loads(message))
              message_received.set()
          
          ws.on_message = on_message
          ws.send(json.dumps({"action": "test"}))
          
          # Wait with timeout instead of fixed sleep
          if not message_received.wait(timeout=5):
              pytest.fail("No message received within timeout")
          
          assert len(received_messages) > 0
  
  - input: |
      # Bad: Not distinguishing between message types
      def on_message(ws, message):
          parsed = json.loads(message)
          received_messages.append(parsed)
    output: |
      # Good: Handling different message types
      def on_message(ws, message):
          parsed = json.loads(message)
          all_messages.append(parsed)
          
          # Distinguish between acknowledgments and actual responses
          if "status" in parsed and parsed["status"] == "Message processed":
              acknowledgments.append(parsed)
          elif "message" in parsed and parsed["message"] != "Processing your request...":
              actual_responses.append(parsed)
              response_received_event.set()

metadata:
  priority: high
  version: 1.0
</rule> 