---
description: Python Testing Best Practices
globs: "**/test_*.py"
alwaysApply: true
---
# Python Testing Best Practices

This rule enforces best practices for writing tests in Python, with a focus on ensuring tests provide business value.

<rule>
name: python_testing
description: Enforce best practices for Python testing
filters:
  - type: file_extension
    pattern: "\\.py$"
  - type: content
    pattern: "(?:import\\s+(?:unittest|pytest)|def\\s+test_)"

actions:
  - type: suggest
    conditions:
      # If test function doesn't have docstring
      - pattern: "def\\s+test_[a-zA-Z0-9_]+\\s*\\([^)]*\\)\\s*:\\s*(?!\\s*[\"'])\\s*\\S+"
        message: "Add docstrings to test functions to explain what they're testing and what business value they provide"
      # If using assert without message
      - pattern: "assert\\s+[^,]+"
        message: "Include a message with assertions to clarify what's being tested"
      # If test has multiple assertions
      - pattern: "def\\s+test_[a-zA-Z0-9_]+[^:]*:(?:[^\\n]*\\n+\\s*)+assert[^\\n]*\\n+(?:[^\\n]*\\n+\\s*)*assert"
        message: "Consider splitting tests with multiple assertions into separate test functions"
      # If test is mocking external dependencies without clear purpose
      - pattern: "@patch\\(['\"][^'\"]+['\"]\\)"
        message: "Ensure mocks are used purposefully and the test provides clear business value"
      # If test has rigid string assertions
      - pattern: "assert\\s+[\"'][^\"']+[\"']\\s+in\\s+.+"
        message: "Consider using more flexible assertions that can handle variations in wording"
      # If committing test files without running them
      - pattern: "git\\s+add\\s+.*test_.*\\.py"
        message: "Verify that tests pass before committing them"
      # If mocking AWS services without proper response structure
      - pattern: "boto3|dynamodb|s3|lambda"
        message: "Ensure AWS service mocks include proper response structures to avoid ResourceNotFound errors"
      # If mocking at the wrong level
      - pattern: "@patch\\(['\"](boto3|aws_sdk|requests)['\"]\\)"
        message: "Consider mocking at a more direct level instead of high-level libraries"
    message: |
      ## Python Testing Best Practices

      Follow these guidelines for writing tests:

      1. **Business Value First**: Only write tests that provide clear business value
         - Tests should verify critical business logic
         - Tests should prevent regressions in important functionality
         - Tests should document expected behavior for key features
      
      2. **Test Quality Over Quantity**
         - Focus on high-value tests rather than high test count
         - Avoid tests that duplicate coverage without adding value
         - Remove tests that are consistently failing without providing useful feedback
      
      3. **Practical Mocking**
         - Only mock external dependencies when necessary
         - Ensure mocks reflect realistic behavior
         - Don't create tests that are overly dependent on implementation details
         - **Mock at the right level**: Prefer mocking the specific components you're testing rather than high-level dependencies
         - **Direct mocking is more reliable**: Mock the specific functions or methods being called rather than their internal dependencies
         - For AWS services, ensure mocks include proper response structures:
           - DynamoDB: Include proper response metadata and expected return values
           - S3: Mock both client and resource interfaces appropriately
           - Lambda: Include proper invocation response format
      
      4. **Flexible Assertions**
         - Use assertions that focus on business requirements, not implementation details
         - For text validation, consider multiple ways the same concept might be expressed
         - Use regular expressions or multiple conditions for flexible string matching
         - Test for semantic meaning rather than exact wording
         - **Match implementation details**: Ensure assertions match the actual implementation details, including return value types (e.g., empty dict vs None)
      
      5. **Appropriate Timeouts**
         - Set realistic timeouts for asynchronous operations
         - Consider environment factors (like cold starts in serverless) when setting timeouts
         - Include clear timeout messages that help diagnose issues
      
      6. **Verify Before Committing**
         - Always run tests before committing them
         - Use test runners like `pytest` or `unittest` to verify functionality
         - Fix failing tests before committing or document known issues
         - Include test verification in your pre-commit workflow
         - For Lambda functions, use the provided `run_tests.py` script
      
      7. **Effective Test Debugging**
         - Debug tests individually rather than running the entire suite when troubleshooting
         - Create debug scripts that run specific test classes or methods in isolation
         - Add detailed logging to tests to understand what's happening during execution
         - Verify environment variables and mock configurations in each test
         - Use descriptive test names that help identify what's being tested
      
      8. **Consistent Mocking Approach**
         - Use a consistent mocking approach throughout the test suite
         - Prefer patching specific components over patching high-level dependencies
         - Document your mocking strategy for complex tests
         - Use setup methods to establish common mocks across multiple tests
      
      9. Include docstrings for all test functions that explain:
         - What is being tested
         - Why it matters (business value)
         - Any special test conditions
      
      10. Follow the Arrange-Act-Assert (AAA) pattern
      
      11. Test one concept per test function
      
      12. Use descriptive assertion messages
      
      13. Use fixtures for test setup and teardown
      
      14. Parameterize tests for multiple input scenarios
      
      15. Aim for high test coverage of critical paths, not 100% coverage

      ### Example of Flexible Text Assertion:
      ```python
      def test_error_message_for_invalid_input():
          """Test that appropriate error message is shown for invalid input.
          
          This test ensures users receive helpful guidance when they
          provide invalid input, which reduces support requests.
          """
          # Arrange
          invalid_input = "abc123"
          
          # Act
          result = process_numeric_input(invalid_input)
          
          # Assert - flexible matching for error message
          error_msg = result.get('error', '').lower()
          assert any(phrase in error_msg for phrase in 
                    ['invalid input', 'not valid', 'must be numeric', 'numbers only']), \
                 f"Error message should indicate invalid input, but got: {error_msg}"
      ```
      
      ### Example of Test Verification Before Commit:
      ```bash
      # For general Python tests
      python -m pytest
      
      # For Lambda function tests
      cd lambda/api
      python run_tests.py
      
      # Only commit if tests pass
      if [ $? -eq 0 ]; then
          git add .
          git commit -m "test: add new tests for feature X"
      else
          echo "Tests failed, fixing before committing"
      fi
      ```
      
      ### Example of Individual Test Debugging:
      ```python
      # debug_tests.py - A script to run tests individually for debugging
      import unittest
      import os
      import sys
      
      # Set up environment variables for testing
      os.environ['CUSTOMERS_TABLE'] = 'test-customers'
      os.environ['SERVICE_LEVELS_TABLE'] = 'test-service-levels'
      
      # Import the test class
      from services.test_dynamodb_service import TestDynamoDBService
      
      # Create a test suite with just one test method
      suite = unittest.TestSuite()
      suite.addTest(TestDynamoDBService('test_update_device_state_success'))
      
      # Run the test with high verbosity
      runner = unittest.TextTestRunner(verbosity=2)
      result = runner.run(suite)
      
      # Print detailed results
      print(f"\nTest passed: {result.wasSuccessful()}")
      if not result.wasSuccessful():
          print(f"Errors: {len(result.errors)}")
          for test, error in result.errors:
              print(f"\n{'-'*40}\nError in {test}:\n{error}")
          
          print(f"Failures: {len(result.failures)}")
          for test, failure in result.failures:
              print(f"\n{'-'*40}\nFailure in {test}:\n{failure}")
      ```
      
      ### Example of Proper AWS Service Mocking:
      ```python
      # Bad: Mocking at too high a level
      @patch('boto3.resource')
      def test_dynamodb_update(mock_boto3_resource):
          mock_table = MagicMock()
          mock_dynamodb = MagicMock()
          mock_dynamodb.Table.return_value = mock_table
          mock_boto3_resource.return_value = mock_dynamodb
          
          result = update_item('item-123', 'new-value')
          assert result is True
      
      # Good: Mocking at the right level
      @patch('services.dynamodb_service.dynamodb.Table')
      def test_dynamodb_update(mock_table_constructor):
          """Test updating an item in DynamoDB.
          
          This test ensures our update operation correctly modifies data,
          which is critical for maintaining data integrity.
          """
          # Arrange
          mock_table = MagicMock()
          # Include proper response structure
          mock_table.update_item.return_value = {
              'ResponseMetadata': {
                  'HTTPStatusCode': 200,
                  'RequestId': 'EXAMPLE-REQUEST-ID'
              },
              'Attributes': {
                  'id': 'item-123',
                  'value': 'new-value',
                  'updated_at': '2023-01-01T12:00:00Z'
              }
          }
          mock_table_constructor.return_value = mock_table
          
          # Act
          result = update_item('item-123', 'new-value')
          
          # Assert
          assert result is True, "Update operation should return True on success"
          mock_table.update_item.assert_called_once()
          # Verify the correct parameters were used
          args, kwargs = mock_table.update_item.call_args
          assert kwargs['Key'] == {'id': 'item-123'}, "Key should match the item ID"
          assert 'UpdateExpression' in kwargs, "Update should include UpdateExpression"
      ```
      
      ### Example of Consistent Mocking Approach:
      ```python
      class TestUserService(unittest.TestCase):
          """Tests for the UserService class."""
          
          def setUp(self):
              """Set up common mocks for all tests."""
              # Patch at the right level consistently across all tests
              self.db_patcher = patch('services.user_service.database.get_connection')
              self.mock_db = self.db_patcher.start()
              self.mock_conn = MagicMock()
              self.mock_db.return_value = self.mock_conn
              
              # Create the service with dependencies properly mocked
              self.user_service = UserService()
              
          def tearDown(self):
              """Clean up patches."""
              self.db_patcher.stop()
              
          def test_get_user(self):
              """Test retrieving a user by ID."""
              # Arrange
              self.mock_conn.execute.return_value.fetchone.return_value = {
                  'id': 'user-123',
                  'name': 'Test User',
                  'email': 'test@example.com'
              }
              
              # Act
              user = self.user_service.get_user('user-123')
              
              # Assert
              self.assertEqual(user['id'], 'user-123')
              self.mock_conn.execute.assert_called_once()
      ```

examples:
  - input: |
      # Bad: Rigid string assertion
      def test_permission_denied_message():
          response = api.access_restricted_resource()
          assert "Permission denied" in response.text
    output: |
      # Good: Flexible string assertion
      def test_permission_denied_message():
          """Test that users receive appropriate message when accessing restricted resources.
          
          This test ensures users understand why they can't access certain resources,
          which improves user experience and reduces support tickets.
          """
          response = api.access_restricted_resource()
          error_text = response.text.lower()
          
          # Check for various ways of expressing the same concept
          permission_denied_phrases = [
              "permission denied", 
              "not authorized", 
              "access denied",
              "insufficient privileges",
              "not allowed"
          ]
          
          assert any(phrase in error_text for phrase in permission_denied_phrases), \
                 f"Response should indicate permission denied, but got: {response.text}"
  
  - input: |
      # Bad: Test without business value justification
      @patch('external_api.get_data')
      def test_process_data(mock_get_data):
          mock_get_data.return_value = {"key": "value"}
          result = process_data()
          assert result == {"processed": "value"}
    output: |
      # Good: Test with clear business value
      @patch('external_api.get_data')
      def test_process_data(mock_get_data):
          """Test that data processing works correctly with API data.
          
          This test verifies that our core data processing function correctly
          transforms external API data, which is critical for our reporting
          feature used by 80% of customers.
          """
          # Arrange
          mock_get_data.return_value = {"key": "value"}
          
          # Act
          result = process_data()
          
          # Assert
          assert result == {"processed": "value"}, "Data should be correctly processed"
  
  - input: |
      # Bad: Mocking at too high a level
      @patch('boto3.resource')
      def test_dynamodb_update(mock_boto3_resource):
          mock_table = MagicMock()
          mock_dynamodb = MagicMock()
          mock_dynamodb.Table.return_value = mock_table
          mock_boto3_resource.return_value = mock_dynamodb
          
          result = update_item('item-123', 'new-value')
          assert result is True
    output: |
      # Good: Mocking at the right level
      @patch('services.dynamodb_service.dynamodb.Table')
      def test_dynamodb_update(mock_table_constructor):
          """Test updating an item in DynamoDB.
          
          This test ensures our update operation correctly modifies data,
          which is critical for maintaining data integrity.
          """
          # Arrange
          mock_table = MagicMock()
          # Include proper response structure
          mock_table.update_item.return_value = {
              'ResponseMetadata': {
                  'HTTPStatusCode': 200,
                  'RequestId': 'EXAMPLE-REQUEST-ID'
              },
              'Attributes': {
                  'id': 'item-123',
                  'value': 'new-value',
                  'updated_at': '2023-01-01T12:00:00Z'
              }
          }
          mock_table_constructor.return_value = mock_table
          
          # Act
          result = update_item('item-123', 'new-value')
          
          # Assert
          assert result is True, "Update operation should return True on success"
          mock_table.update_item.assert_called_once()
          # Verify the correct parameters were used
          args, kwargs = mock_table.update_item.call_args
          assert kwargs['Key'] == {'id': 'item-123'}, "Key should match the item ID"
          assert 'UpdateExpression' in kwargs, "Update should include UpdateExpression"

metadata:
  priority: high
  version: 1.6
</rule> 