---
description: Python Testing Best Practices
globs: "**/test_*.py"
alwaysApply: true
---
# Python Testing Best Practices

This rule enforces best practices for writing tests in Python, with a focus on ensuring tests provide business value.

<rule>
name: python_testing
description: Enforce best practices for Python testing
filters:
  - type: file_extension
    pattern: "\\.py$"
  - type: content
    pattern: "(?:import\\s+(?:unittest|pytest)|def\\s+test_)"

actions:
  - type: suggest
    conditions:
      # If test function doesn't have docstring
      - pattern: "def\\s+test_[a-zA-Z0-9_]+\\s*\\([^)]*\\)\\s*:\\s*(?!\\s*[\"'])\\s*\\S+"
        message: "Add docstrings to test functions to explain what they're testing and what business value they provide"
      # If using assert without message
      - pattern: "assert\\s+[^,]+"
        message: "Include a message with assertions to clarify what's being tested"
      # If test has multiple assertions
      - pattern: "def\\s+test_[a-zA-Z0-9_]+[^:]*:(?:[^\\n]*\\n+\\s*)+assert[^\\n]*\\n+(?:[^\\n]*\\n+\\s*)*assert"
        message: "Consider splitting tests with multiple assertions into separate test functions"
      # If test is mocking external dependencies without clear purpose
      - pattern: "@patch\\(['\"][^'\"]+['\"]\\)"
        message: "Ensure mocks are used purposefully and the test provides clear business value"
      # If test has rigid string assertions
      - pattern: "assert\\s+[\"'][^\"']+[\"']\\s+in\\s+.+"
        message: "Consider using more flexible assertions that can handle variations in wording"
      # If committing test files without running them
      - pattern: "git\\s+add\\s+.*test_.*\\.py"
        message: "Verify that tests pass before committing them"
      # If mocking AWS services without proper response structure
      - pattern: "boto3|dynamodb|s3|lambda"
        message: "Ensure AWS service mocks include proper response structures to avoid ResourceNotFound errors"
      # If mocking at the wrong level
      - pattern: "@patch\\(['\"](boto3|aws_sdk|requests)['\"]\\)"
        message: "Consider mocking at a more direct level instead of high-level libraries"
      # If testing WebSocket connections
      - pattern: "websocket|WebSocket|ws:|wss:"
        message: "Ensure WebSocket tests handle connection lifecycle and message validation properly"
      # If testing service level permissions
      - pattern: "permission|authorize|role|policy"
        message: "Ensure service level permission tests verify both positive and negative access scenarios"
    message: |
      ## Python Testing Best Practices

      Follow these guidelines for writing tests:

      1. **Business Value First**: Only write tests that provide clear business value
         - Tests should verify critical business logic
         - Tests should prevent regressions in important functionality
         - Tests should document expected behavior for key features
      
      2. **Test Quality Over Quantity**
         - Focus on high-value tests rather than high test count
         - Avoid tests that duplicate coverage without adding value
         - Remove tests that are consistently failing without providing useful feedback
      
      3. **Practical Mocking**
         - Only mock external dependencies when necessary
         - Ensure mocks reflect realistic behavior
         - Don't create tests that are overly dependent on implementation details
         - **Mock at the right level**: Prefer mocking the specific components you're testing rather than high-level dependencies
         - **Direct mocking is more reliable**: Mock the specific functions or methods being called rather than their internal dependencies
         - For AWS services, ensure mocks include proper response structures:
           - DynamoDB: Include proper response metadata and expected return values
           - S3: Mock both client and resource interfaces appropriately
           - Lambda: Include proper invocation response format
      
      4. **Flexible Assertions**
         - Use assertions that focus on business requirements, not implementation details
         - For text validation, consider multiple ways the same concept might be expressed
         - Use regular expressions or multiple conditions for flexible string matching
         - Test for semantic meaning rather than exact wording
         - **Match implementation details**: Ensure assertions match the actual implementation details, including return value types (e.g., empty dict vs None)
      
      5. **Appropriate Timeouts**
         - Set realistic timeouts for asynchronous operations
         - Consider environment factors (like cold starts in serverless) when setting timeouts
         - Include clear timeout messages that help diagnose issues
      
      6. **Verify Before Committing**
         - Always run tests before committing them
         - Use test runners like `pytest` or `unittest` to verify functionality
         - Fix failing tests before committing or document known issues
         - Include test verification in your pre-commit workflow
         - For Lambda functions, use the provided `run_tests.py` script
      
      7. **Effective Test Debugging**
         - Debug tests individually rather than running the entire suite when troubleshooting
         - Create debug scripts that run specific test classes or methods in isolation
         - Add detailed logging to tests to understand what's happening during execution
         - Verify environment variables and mock configurations in each test
         - Use descriptive test names that help identify what's being tested
      
      8. **Consistent Mocking Approach**
         - Use a consistent mocking approach throughout the test suite
         - Prefer patching specific components over patching high-level dependencies
         - Document your mocking strategy for complex tests
         - Use setup methods to establish common mocks across multiple tests
      
      9. **WebSocket Testing Best Practices**
         - Test the full WebSocket lifecycle (connection, message exchange, disconnection)
         - Verify connection establishment with proper headers and authentication
         - Test message serialization/deserialization for both sending and receiving
         - Implement timeout handling for asynchronous WebSocket operations
         - Test reconnection logic and error handling for dropped connections
         - Verify proper cleanup of resources when connections are closed
         - Use mock WebSocket servers to simulate various server behaviors
         - Test handling of different message types (text, binary, ping/pong)
         - Verify proper handling of concurrent connections and messages
      
      10. **Service Level Permission Testing**
         - Test both positive and negative permission scenarios
         - Verify that authorized users can access protected resources
         - Confirm that unauthorized users receive appropriate error responses
         - Test permission inheritance and role hierarchies
         - Verify that permission changes take effect immediately
         - Test cross-service permission boundaries
         - Validate that permission checks are applied consistently across all access points
         - Test permission caching and expiration behavior
         - Verify proper logging of permission-related events
         - Test permission delegation and temporary access scenarios
      
      11. Include docstrings for all test functions that explain:
         - What is being tested
         - Why it matters (business value)
         - Any special test conditions
      
      12. Follow the Arrange-Act-Assert (AAA) pattern
      
      13. Test one concept per test function
      
      14. Use descriptive assertion messages
      
      15. Use fixtures for test setup and teardown
      
      16. Parameterize tests for multiple input scenarios
      
      17. Aim for high test coverage of critical paths, not 100% coverage

      ### Example of Flexible Text Assertion:
      ```python
      def test_error_message_for_invalid_input():
          """Test that appropriate error message is shown for invalid input.
          
          This test ensures users receive helpful guidance when they
          provide invalid input, which reduces support requests.
          """
          # Arrange
          invalid_input = "abc123"
          
          # Act
          result = process_numeric_input(invalid_input)
          
          # Assert - flexible matching for error message
          error_msg = result.get('error', '').lower()
          assert any(phrase in error_msg for phrase in 
                    ['invalid input', 'not valid', 'must be numeric', 'numbers only']), \
                 f"Error message should indicate invalid input, but got: {error_msg}"
      ```
      
      ### Example of Test Verification Before Commit:
      ```bash
      # For general Python tests
      python -m pytest
      
      # For Lambda function tests
      cd lambda/api
      python run_tests.py
      
      # Only commit if tests pass
      if [ $? -eq 0 ]; then
          git add .
          git commit -m "test: add new tests for feature X"
      else
          echo "Tests failed, fixing before committing"
      fi
      ```
      
      ### Example of Individual Test Debugging:
      ```python
      # debug_tests.py - A script to run tests individually for debugging
      import unittest
      import os
      import sys
      
      # Set up environment variables for testing
      os.environ['CUSTOMERS_TABLE'] = 'test-customers'
      os.environ['SERVICE_LEVELS_TABLE'] = 'test-service-levels'
      
      # Import the test class
      from services.test_dynamodb_service import TestDynamoDBService
      
      # Create a test suite with just one test method
      suite = unittest.TestSuite()
      suite.addTest(TestDynamoDBService('test_update_device_state_success'))
      
      # Run the test with high verbosity
      runner = unittest.TextTestRunner(verbosity=2)
      result = runner.run(suite)
      
      # Print detailed results
      print(f"\nTest passed: {result.wasSuccessful()}")
      if not result.wasSuccessful():
          print(f"Errors: {len(result.errors)}")
          for test, error in result.errors:
              print(f"\n{'-'*40}\nError in {test}:\n{error}")
          
          print(f"Failures: {len(result.failures)}")
          for test, failure in result.failures:
              print(f"\n{'-'*40}\nFailure in {test}:\n{failure}")
      ```
      
      ### Example of Proper AWS Service Mocking:
      ```python
      # Bad: Mocking at too high a level
      @patch('boto3.resource')
      def test_dynamodb_update(mock_boto3_resource):
          mock_table = MagicMock()
          mock_dynamodb = MagicMock()
          mock_dynamodb.Table.return_value = mock_table
          mock_boto3_resource.return_value = mock_dynamodb
          
          result = update_item('item-123', 'new-value')
          assert result is True
      
      # Good: Mocking at the right level
      @patch('services.dynamodb_service.dynamodb.Table')
      def test_dynamodb_update(mock_table_constructor):
          """Test updating an item in DynamoDB.
          
          This test ensures our update operation correctly modifies data,
          which is critical for maintaining data integrity.
          """
          # Arrange
          mock_table = MagicMock()
          # Include proper response structure
          mock_table.update_item.return_value = {
              'ResponseMetadata': {
                  'HTTPStatusCode': 200,
                  'RequestId': 'EXAMPLE-REQUEST-ID'
              },
              'Attributes': {
                  'id': 'item-123',
                  'value': 'new-value',
                  'updated_at': '2023-01-01T12:00:00Z'
              }
          }
          mock_table_constructor.return_value = mock_table
          
          # Act
          result = update_item('item-123', 'new-value')
          
          # Assert
          assert result is True, "Update operation should return True on success"
          mock_table.update_item.assert_called_once()
          # Verify the correct parameters were used
          args, kwargs = mock_table.update_item.call_args
          assert kwargs['Key'] == {'id': 'item-123'}, "Key should match the item ID"
          assert 'UpdateExpression' in kwargs, "Update should include UpdateExpression"
      ```
      
      ### Example of Consistent Mocking Approach:
      ```python
      class TestUserService(unittest.TestCase):
          """Tests for the UserService class."""
          
          def setUp(self):
              """Set up common mocks for all tests."""
              # Patch at the right level consistently across all tests
              self.db_patcher = patch('services.user_service.database.get_connection')
              self.mock_db = self.db_patcher.start()
              self.mock_conn = MagicMock()
              self.mock_db.return_value = self.mock_conn
              
              # Create the service with dependencies properly mocked
              self.user_service = UserService()
              
          def tearDown(self):
              """Clean up patches."""
              self.db_patcher.stop()
              
          def test_get_user(self):
              """Test retrieving a user by ID."""
              # Arrange
              self.mock_conn.execute.return_value.fetchone.return_value = {
                  'id': 'user-123',
                  'name': 'Test User',
                  'email': 'test@example.com'
              }
              
              # Act
              user = self.user_service.get_user('user-123')
              
              # Assert
              self.assertEqual(user['id'], 'user-123')
              self.mock_conn.execute.assert_called_once()
      ```
      
      ### Example of WebSocket Testing:
      ```python
      @pytest.fixture
      def mock_websocket_server():
          """Fixture to create a mock WebSocket server for testing."""
          server = MockWebSocketServer('localhost', 8765)
          server.start()
          yield server
          server.stop()
      
      def test_websocket_connection_lifecycle(mock_websocket_server):
          """Test the full lifecycle of a WebSocket connection.
          
          This test verifies our client can properly establish, maintain,
          and close WebSocket connections, which is critical for real-time
          communication with devices.
          """
          # Arrange
          client = WebSocketClient('ws://localhost:8765')
          
          # Act - Connect
          connected = client.connect()
          
          # Assert - Connection successful
          assert connected is True, "Client should connect successfully to the WebSocket server"
          
          # Act - Send message
          success = client.send_message({"type": "command", "action": "start"})
          
          # Assert - Message sent successfully
          assert success is True, "Client should send message successfully"
          
          # Act - Receive response
          response = client.receive_message(timeout=2.0)
          
          # Assert - Response received and valid
          assert response is not None, "Client should receive a response"
          assert response.get("status") == "ok", f"Response should have 'ok' status, got: {response}"
          
          # Act - Disconnect
          disconnected = client.disconnect()
          
          # Assert - Disconnection successful
          assert disconnected is True, "Client should disconnect cleanly"
          
          # Verify server side received expected messages
          messages = mock_websocket_server.get_received_messages()
          assert len(messages) == 1, "Server should have received exactly one message"
          assert messages[0].get("type") == "command", "Message should have correct type"
      ```
      
      ### Example of Service Level Permission Testing:
      ```python
      def test_service_level_permission_access_allowed():
          """Test that users with appropriate permissions can access protected resources.
          
          This test ensures our permission system correctly grants access to authorized users,
          which is critical for maintaining proper security boundaries while allowing
          legitimate access.
          """
          # Arrange
          user_id = "user-with-admin-role"
          resource_id = "protected-resource-123"
          permission_service = PermissionService()
          
          # Mock the permission lookup
          with patch('services.permission_service.get_user_roles') as mock_get_roles:
              mock_get_roles.return_value = ["admin", "editor"]
              
              # Act
              has_permission = permission_service.check_access(user_id, resource_id, "read")
              
              # Assert
              assert has_permission is True, "User with admin role should have read access"
              mock_get_roles.assert_called_once_with(user_id)
      
      def test_service_level_permission_access_denied():
          """Test that users without appropriate permissions cannot access protected resources.
          
          This test verifies our permission system correctly denies access to unauthorized users,
          which is essential for maintaining security and data isolation between customers.
          """
          # Arrange
          user_id = "user-with-viewer-role"
          resource_id = "protected-resource-123"
          permission_service = PermissionService()
          
          # Mock the permission lookup
          with patch('services.permission_service.get_user_roles') as mock_get_roles:
              mock_get_roles.return_value = ["viewer"]
              
              # Act
              has_permission = permission_service.check_access(user_id, resource_id, "write")
              
              # Assert
              assert has_permission is False, "User with viewer role should not have write access"
              mock_get_roles.assert_called_once_with(user_id)
              
          # Verify proper error response when attempting to access
          with patch('services.permission_service.get_user_roles') as mock_get_roles:
              mock_get_roles.return_value = ["viewer"]
              
              # Act
              response = permission_service.attempt_resource_operation(user_id, resource_id, "write")
              
              # Assert
              assert response.get("success") is False, "Operation should not succeed"
              assert "permission denied" in response.get("error", "").lower(), \
                     f"Error should indicate permission denied, got: {response.get('error')}"
      ```

examples:
  - input: |
      # Bad: Rigid string assertion
      def test_permission_denied_message():
          response = api.access_restricted_resource()
          assert "Permission denied" in response.text
    output: |
      # Good: Flexible string assertion
      def test_permission_denied_message():
          """Test that users receive appropriate message when accessing restricted resources.
          
          This test ensures users understand why they can't access certain resources,
          which improves user experience and reduces support tickets.
          """
          response = api.access_restricted_resource()
          error_text = response.text.lower()
          
          # Check for various ways of expressing the same concept
          permission_denied_phrases = [
              "permission denied", 
              "not authorized", 
              "access denied",
              "insufficient privileges",
              "not allowed"
          ]
          
          assert any(phrase in error_text for phrase in permission_denied_phrases), \
                 f"Response should indicate permission denied, but got: {response.text}"
  
  - input: |
      # Bad: Test without business value justification
      @patch('external_api.get_data')
      def test_process_data(mock_get_data):
          mock_get_data.return_value = {"key": "value"}
          result = process_data()
          assert result == {"processed": "value"}
    output: |
      # Good: Test with clear business value
      @patch('external_api.get_data')
      def test_process_data(mock_get_data):
          """Test that data processing works correctly with API data.
          
          This test verifies that our core data processing function correctly
          transforms external API data, which is critical for our reporting
          feature used by 80% of customers.
          """
          # Arrange
          mock_get_data.return_value = {"key": "value"}
          
          # Act
          result = process_data()
          
          # Assert
          assert result == {"processed": "value"}, "Data should be correctly processed"
  
  - input: |
      # Bad: Mocking at too high a level
      @patch('boto3.resource')
      def test_dynamodb_update(mock_boto3_resource):
          mock_table = MagicMock()
          mock_dynamodb = MagicMock()
          mock_dynamodb.Table.return_value = mock_table
          mock_boto3_resource.return_value = mock_dynamodb
          
          result = update_item('item-123', 'new-value')
          assert result is True
    output: |
      # Good: Mocking at the right level
      @patch('services.dynamodb_service.dynamodb.Table')
      def test_dynamodb_update(mock_table_constructor):
          """Test updating an item in DynamoDB.
          
          This test ensures our update operation correctly modifies data,
          which is critical for maintaining data integrity.
          """
          # Arrange
          mock_table = MagicMock()
          # Include proper response structure
          mock_table.update_item.return_value = {
              'ResponseMetadata': {
                  'HTTPStatusCode': 200,
                  'RequestId': 'EXAMPLE-REQUEST-ID'
              },
              'Attributes': {
                  'id': 'item-123',
                  'value': 'new-value',
                  'updated_at': '2023-01-01T12:00:00Z'
              }
          }
          mock_table_constructor.return_value = mock_table
          
          # Act
          result = update_item('item-123', 'new-value')
          
          # Assert
          assert result is True, "Update operation should return True on success"
          mock_table.update_item.assert_called_once()
          # Verify the correct parameters were used
          args, kwargs = mock_table.update_item.call_args
          assert kwargs['Key'] == {'id': 'item-123'}, "Key should match the item ID"
          assert 'UpdateExpression' in kwargs, "Update should include UpdateExpression"
  
  - input: |
      # Bad: WebSocket test without proper lifecycle testing
      def test_websocket():
          client = WebSocketClient('ws://localhost:8765')
          client.connect()
          client.send_message({"type": "command"})
          assert client.is_connected()
    output: |
      # Good: Complete WebSocket lifecycle testing
      def test_websocket_connection_lifecycle():
          """Test the full lifecycle of a WebSocket connection.
          
          This test verifies our client can properly establish, maintain,
          and close WebSocket connections, which is critical for real-time
          communication with devices.
          """
          # Arrange
          client = WebSocketClient('ws://localhost:8765')
          
          # Act - Connect
          connected = client.connect()
          
          # Assert - Connection successful
          assert connected is True, "Client should connect successfully"
          
          # Act - Send message
          success = client.send_message({"type": "command", "action": "start"})
          
          # Assert - Message sent successfully
          assert success is True, "Client should send message successfully"
          
          # Act - Receive response (with timeout)
          response = client.receive_message(timeout=2.0)
          
          # Assert - Response received and valid
          assert response is not None, "Client should receive a response"
          assert response.get("status") == "ok", "Response should have 'ok' status"
          
          # Act - Disconnect
          disconnected = client.disconnect()
          
          # Assert - Disconnection successful
          assert disconnected is True, "Client should disconnect cleanly"
          
          # Verify resources were cleaned up
          assert client.connection is None, "Connection should be properly cleaned up"
  
  - input: |
      # Bad: Permission test that only checks positive case
      def test_user_permissions():
          user = User(role="admin")
          assert user.can_access_admin_panel() is True
    output: |
      # Good: Permission tests for both positive and negative cases
      def test_user_permission_positive_case():
          """Test that admin users can access the admin panel.
          
          This test verifies that our permission system correctly grants
          access to users with admin privileges, which is essential for
          administrative functions.
          """
          # Arrange
          user = User(role="admin")
          
          # Act
          can_access = user.can_access_admin_panel()
          
          # Assert
          assert can_access is True, "Admin users should be able to access the admin panel"
      
      def test_user_permission_negative_case():
          """Test that non-admin users cannot access the admin panel.
          
          This test ensures our permission system correctly prevents
          unauthorized access to administrative functions, which is
          critical for security.
          """
          # Arrange
          user = User(role="regular")
          
          # Act
          can_access = user.can_access_admin_panel()
          
          # Assert
          assert can_access is False, "Regular users should not be able to access the admin panel"
          
          # Verify proper error response when attempting to access
          response = user.attempt_admin_panel_access()
          assert response.status_code == 403, "Should return 403 Forbidden status code"
          assert "not authorized" in response.text.lower(), "Should indicate authorization failure"

metadata:
  priority: high
  version: 1.7
</rule> 