# WebSocket Connection Handling Best Practices

This rule enforces best practices for handling WebSocket connections in Python applications.

<rule>
name: websocket_best_practices
description: Enforce best practices for WebSocket connection handling
filters:
  - type: file_extension
    pattern: "\\.py$"
  - type: content
    pattern: "(?:websocket|WebSocket|ws\\.)"

actions:
  - type: suggest
    conditions:
      # If sending message without checking connection status
      - pattern: "ws\\.send\\([^)]+\\)(?!.*(?:try|except|is_connected|status))"
        message: "Always check connection status before sending messages"
      # If not handling connection errors
      - pattern: "def\\s+[a-zA-Z0-9_]+[^:]*:\\s*(?:[^\\n]*\\n+\\s*)*ws\\.(?:send|close)\\([^)]*\\)(?!.*(?:try|except))"
        message: "Add error handling around WebSocket operations"
      # If using short timeouts
      - pattern: "timeout\\s*=\\s*[0-9](?:\\.[0-9]+)?"
        message: "Consider using longer timeouts for WebSocket operations, especially in serverless environments"
    message: |
      ## WebSocket Connection Handling Best Practices

      Follow these guidelines for handling WebSocket connections:

      1. **Robust Connection Management**
         - Always check if a connection is valid before sending messages
         - Implement reconnection logic for handling disconnections
         - Close connections properly when they're no longer needed
         - Use connection IDs or other identifiers to track connections
      
      2. **Comprehensive Error Handling**
         - Wrap WebSocket operations in try-except blocks
         - Handle specific WebSocket exceptions (connection closed, timeout, etc.)
         - Log detailed error information for debugging
         - Implement graceful degradation when WebSocket operations fail
      
      3. **Appropriate Timeouts**
         - Set realistic timeouts for connection establishment and message exchange
         - Consider environment factors (like serverless cold starts) when setting timeouts
         - Implement progressive backoff for reconnection attempts
      
      4. **Connection Validation**
         - Periodically check if connections are still valid
         - Implement ping/pong mechanisms to keep connections alive
         - Clean up stale connections to free resources
      
      5. **Retry Logic**
         - Implement retry logic for critical WebSocket operations
         - Use exponential backoff between retry attempts
         - Set a maximum number of retries to prevent infinite loops
      
      6. **Detailed Logging**
         - Log connection events (connect, disconnect, reconnect)
         - Log message send/receive events with appropriate detail
         - Include connection IDs in logs for correlation
         - Log timing information for performance monitoring

      ### Example:
      ```python
      def send_message(connection_id, message, max_retries=3):
          """Send a message to a WebSocket client with retry logic.
          
          Args:
              connection_id: The WebSocket connection ID
              message: The message to send
              max_retries: Maximum number of retry attempts
              
          Returns:
              True if successful, False otherwise
          """
          retries = 0
          
          while retries <= max_retries:
              try:
                  # Check if connection is valid before sending
                  if not is_connection_valid(connection_id):
                      logger.error(f"Connection {connection_id} is invalid")
                      return False
                      
                  logger.info(f"Sending message to connection {connection_id} (attempt {retries + 1})")
                  ws_client.post_to_connection(
                      ConnectionId=connection_id,
                      Data=json.dumps(message).encode('utf-8')
                  )
                  logger.info(f"Message sent successfully to connection {connection_id}")
                  return True
              except ConnectionError as e:
                  logger.warning(f"Connection error for {connection_id}: {str(e)}")
                  # Mark connection as disconnected
                  update_connection_status(connection_id, "disconnected")
                  return False
              except Exception as e:
                  retries += 1
                  logger.warning(f"Error sending message (attempt {retries}): {str(e)}")
                  
                  if retries <= max_retries:
                      # Exponential backoff
                      wait_time = 0.5 * (2 ** (retries - 1))
                      logger.info(f"Retrying in {wait_time} seconds...")
                      time.sleep(wait_time)
                  else:
                      logger.error(f"Failed to send message after {max_retries + 1} attempts")
                      return False
          
          return False
      ```

examples:
  - input: |
      # Bad: No error handling or connection validation
      def send_message(connection_id, message):
          ws_client.post_to_connection(
              ConnectionId=connection_id,
              Data=json.dumps(message).encode('utf-8')
          )
          return True
    output: |
      # Good: With error handling and connection validation
      def send_message(connection_id, message, max_retries=3):
          """Send a message to a WebSocket client.
          
          Args:
              connection_id: The WebSocket connection ID
              message: The message to send
              max_retries: Maximum number of retry attempts
              
          Returns:
              True if successful, False otherwise
          """
          retries = 0
          
          while retries <= max_retries:
              try:
                  # Validate connection first
                  try:
                      ws_client.get_connection(ConnectionId=connection_id)
                      logger.info(f"Connection {connection_id} is valid")
                  except Exception as conn_err:
                      logger.error(f"Connection {connection_id} is invalid: {str(conn_err)}")
                      return False
                  
                  # Send the message
                  ws_client.post_to_connection(
                      ConnectionId=connection_id,
                      Data=json.dumps(message).encode('utf-8')
                  )
                  logger.info(f"Message sent successfully to connection {connection_id}")
                  return True
              except Exception as e:
                  retries += 1
                  logger.warning(f"Error sending message (attempt {retries}): {str(e)}")
                  
                  if retries <= max_retries:
                      time.sleep(0.5)  # Wait before retrying
                  else:
                      logger.error(f"Failed to send message after {max_retries + 1} attempts")
                      return False
          
          return False
  
  - input: |
      # Bad: Short timeout and no reconnection logic
      def connect_websocket(url):
          ws = websocket.WebSocketApp(url)
          ws.run_forever(timeout=1)
          return ws
    output: |
      # Good: Appropriate timeout and reconnection logic
      def connect_websocket(url, max_retries=3):
          """Connect to a WebSocket with reconnection logic.
          
          Args:
              url: The WebSocket URL to connect to
              max_retries: Maximum number of reconnection attempts
              
          Returns:
              The WebSocket connection object
          """
          retries = 0
          
          while retries <= max_retries:
              try:
                  logger.info(f"Connecting to WebSocket (attempt {retries + 1})")
                  ws = websocket.WebSocketApp(
                      url,
                      on_open=on_open,
                      on_message=on_message,
                      on_error=on_error,
                      on_close=on_close
                  )
                  
                  # Start WebSocket connection with appropriate timeouts
                  wst = threading.Thread(
                      target=lambda: ws.run_forever(ping_interval=30, ping_timeout=10, timeout=10)
                  )
                  wst.daemon = True
                  wst.start()
                  
                  # Wait for connection to establish
                  if connection_established_event.wait(timeout=10):
                      logger.info("WebSocket connection established successfully")
                      return ws
                  else:
                      logger.warning("WebSocket connection timed out")
                      retries += 1
              except Exception as e:
                  logger.error(f"Error connecting to WebSocket: {str(e)}")
                  retries += 1
                  
              if retries <= max_retries:
                  wait_time = 1 * (2 ** (retries - 1))  # Exponential backoff
                  logger.info(f"Retrying connection in {wait_time} seconds...")
                  time.sleep(wait_time)
          
          logger.error(f"Failed to connect after {max_retries + 1} attempts")
          return None

metadata:
  priority: high
  version: 1.0
</rule> 